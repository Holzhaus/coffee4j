package de.rwth.swc.coffee4j.model.manager;

import de.rwth.swc.coffee4j.engine.TestResult;
import de.rwth.swc.coffee4j.engine.constraint.diagnosis.InternalConflict;
import de.rwth.swc.coffee4j.engine.constraint.diagnosis.InternalConflictingConstraintsException;
import de.rwth.swc.coffee4j.engine.manager.CombinatorialTestConfiguration;
import de.rwth.swc.coffee4j.engine.manager.CombinatorialTestManager;
import de.rwth.swc.coffee4j.engine.util.CombinationUtil;
import de.rwth.swc.coffee4j.engine.util.Preconditions;
import de.rwth.swc.coffee4j.model.Combination;
import de.rwth.swc.coffee4j.model.InputParameterModel;
import de.rwth.swc.coffee4j.model.constraints.Constraint;
import de.rwth.swc.coffee4j.model.converter.ModelConverter;
import de.rwth.swc.coffee4j.model.converter.ModelConverterFactory;
import de.rwth.swc.coffee4j.model.report.ExecutionReporter;
import de.rwth.swc.coffee4j.model.report.ModelBasedArgumentConverter;
import de.rwth.swc.coffee4j.model.report.PrintStreamExecutionReporter;

import java.util.Arrays;
import java.util.List;
import java.util.function.Consumer;
import java.util.stream.Collectors;

/**
 * A manager for converting test inputs using a {@link ModelConverter} and putting them into a provided consumer.
 * Uses a {@link DelegatingModelBasedArgumentConverter} and {@link DelegatingExecutionReporter}
 * and {@link ExecutionReporterToGenerationReporterAdapter} to convert between different representations and allow multiple converts
 * and reporter even though method in engine only accept one.
 */
public class CombinatorialTestConsumerManager {
    
    private final ModelConverter modelConverter;
    
    private final CombinatorialTestManager generator;
    
    private final Consumer<Combination> testInputConsumer;
    
    /**
     * Creates a new manager with the given configuration, consumer and model.
     *
     * @param configuration     all needed configuration for a combinatorial test. This is the part which can be reused
     *                          across different tests. Must not be {@code null}
     * @param testInputConsumer a consumer for all test inputs generated by the {@link CombinatorialTestManager}
     *                          provided by the configuration. Each test input is converted using a {@link ModelConverter}
     *                          generated by the provided
     *                          {@link ModelConverterFactory}.
     *                          This part is generally not reusable. Must not be {@code null}
     * @param model             the model which defines all parameters and constraints for a combinatorial test. This part
     *                          is generally not reusable. Must not be {@code null}
     */
    public CombinatorialTestConsumerManager(CombinatorialTestConsumerManagerConfiguration configuration,
                                            Consumer<Combination> testInputConsumer,
                                            InputParameterModel model) {
        Preconditions.notNull(configuration);
        Preconditions.notNull(testInputConsumer);
        Preconditions.notNull(model);
        
        this.testInputConsumer = testInputConsumer;
        modelConverter = configuration.getModelConverterFactory().create(model);
        
        final ModelBasedArgumentConverter argumentConverterManager =
                new DelegatingModelBasedArgumentConverter(configuration.getArgumentConverters());
        argumentConverterManager.initialize(modelConverter);

        final ExecutionReporterToGenerationReporterAdapter reporterManager =
                new ExecutionReporterToGenerationReporterAdapter(
                        buildDelegatingOrDefaultExecutionReporter(configuration.getExecutionReporters()),
                        argumentConverterManager,
                        modelConverter);

        final CombinatorialTestConfiguration managerConfiguration =
                new CombinatorialTestConfiguration(
                        configuration.getCharacterizationAlgorithmFactory().orElse(null),
                        configuration.getGenerators(),
                        reporterManager);

        generator = configuration.getManagerFactory()
                .apply(managerConfiguration, modelConverter.getConvertedModel());
    }

    private ExecutionReporter buildDelegatingOrDefaultExecutionReporter(List<ExecutionReporter> executionReporters) {
        if(executionReporters.isEmpty()) {
            return new PrintStreamExecutionReporter();
        } else {
            return new DelegatingExecutionReporter(executionReporters);
        }
    }

    /**
     * Checks for conflicts among error-constraints, converts them and reports them to System.out.
     * @return true if not conflicts were detected
     *         false if conflicts were detected
     * TODO: integrate reporting of conflicts into Reporter component
     */
    public boolean checkConstraintsForConflicts() {
        List<InternalConflict> internalConflicts = generator.checkConstraintsForConflicts();

        if(internalConflicts.isEmpty()) {
            return true;
        }

        System.out.println("ERROR: Conflicts among constraints detected!");
        System.out.println("--------------------------------------------");
        System.out.println();

        for(InternalConflict internalConflict : internalConflicts) {
            reportInternalConflict(internalConflict);
        }

        return false;
    }

    /**
     * Generates the initial test inputs, converts them and propagates them to the consumer given in the constructor.
     */
    public synchronized void generateInitialTests() {
        generator.generateInitialTests()
                .stream()
                .map(modelConverter::convertCombination)
                .forEach(testInputConsumer);
    }

    private void reportInternalConflict(InternalConflict internalConflict) {
        final int [] tuple = convertTupleFromDualRepresentation(internalConflict.getParameters(), internalConflict.getValues());
        final Combination combination = modelConverter.convertCombination(tuple);

        final Constraint sourceConstraint = modelConverter.convertConstraint(internalConflict.getSourceTupleList());

        final Constraint[] targetConstraints = Arrays.stream(internalConflict.getTargetTupleLists())
                .map(modelConverter::convertConstraint)
                .toArray(Constraint[]::new);

        System.out.println("For error-constraint \n\t" + sourceConstraint + ",\n\t" + combination + "\nis missing.");

        if(targetConstraints.length == 1 && targetConstraints[0] == sourceConstraint) {
            System.out.println("The error-constraint itself seems to be incorrect.");
        } else if(targetConstraints.length > 0) {
            System.out.println("The interaction with \n\t"
                    + Arrays.stream(targetConstraints).map(Constraint::toString).collect(Collectors.joining(",\n\t"))
                    + "\nis causing the absence.");
        } else {
            System.out.println("But, a minimal conflict could not be identified.");
        }

        System.out.println("Please repair the constraints and re-run the tests.");
        System.out.println();
    }

    private int[] convertTupleFromDualRepresentation(int[] parameters, int[] values) {
        final int[] convertedTuple = new int[modelConverter.getConvertedModel().getParameterSizes().length];
        Arrays.fill(convertedTuple, CombinationUtil.NO_VALUE);

        for(int i = 0; i < parameters.length; i++) {
            int parameter = parameters[i];
            int value = values[i];

            convertedTuple[parameter] = value;
        }

        return convertedTuple;
    }

    
    /**
     * Generates additional test inputs based on a new test result. All returned test inputs are converted and then
     * propagated to the given consumer.
     *
     * @param testInput  a test input. Must not be {@code null}
     * @param testResult the result of the test input. Must not be {@code null}
     */
    public synchronized void generateAdditionalTestInputsWithResult(Combination testInput, TestResult testResult) {
        Preconditions.notNull(testInput);
        Preconditions.notNull(testResult);
        
        generator.generateAdditionalTestInputsWithResult(modelConverter.convertCombination(testInput), testResult).stream().map(modelConverter::convertCombination).forEach(testInputConsumer);
    }
}
